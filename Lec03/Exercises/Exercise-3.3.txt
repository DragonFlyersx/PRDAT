Main ::= Expr EOF rule A
Expr ::= NAME rule B
    | CSTINT rule C
    | MINUS CSTINT rule D
    | LPAR Expr RPAR rule E
    | LET NAME EQ Expr IN Expr END rule F
    | Expr TIMES Expr rule G
    | Expr PLUS Expr rule H
    | Expr MINUS Expr rule I
    
Right most derivation of the input: let z = (17) in z + 2 * 3 end EOF 


let z = ( 17 ) in z + 2 * 3 end EOF





Dvs når vi right drivation så er det den mest højre non terminal symbol vi udvider først

This is with respect to the grammar: And Right most derivation:

Main 
=> Expr EOF (rule A)
=> LET NAME EQ Expr IN Expr END EOF (rule F)
=> LET NAME EQ Expr IN Expr TIMES Expr END EOF (rule G)
=> LET NAME EQ Expr IN Expr TIMES CSTINT END EOF (rule C)
=> LET NAME EQ Expr IN Expr PLUS Expr TIMES CSTINT END EOF (rule H)
=> LET NAME EQ Expr IN Expr PLUS CSTINT TIMES CSTINT END EOF (rule C)
=> LET NAME EQ Expr IN NAME PLUS CSTINT TIMES CSTINT END EOF (rule B)
=> LET NAME EQ LPAR Expr RPAR IN NAME PLUS CSTINT TIMES CSTINT END EOF (rule E)
=> LET NAME EQ LPAR CSTINT RPAR IN NAME PLUS CSTINT TIMES CSTINT END EOF (rule C)




  
  
  S -> SS
  S -> aSb
  s -> epsilon
  
  Højre afledning:
    s => S(S) => SaSb => Sab => ab
  Venstre afledning:
    s => (S)S => (aSb)S => (ab)S => (ab)(ab) => abab
  
  
  NON TERMINAL SYMBOLS:
    S
  TERMINAL SYMBOLS: 
    a, b
    START SYMBOL:
    s