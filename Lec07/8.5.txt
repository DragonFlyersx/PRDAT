Updated the abstract syntax with:
 | Cond of expr * expr * expr       (* Conditional expression e1 ? e2 : e3 *)
 
Updated the Lexer with:
 | "?"    { CondToken }
 | ":"    { ColonToken }
 
Updated the Parser with:
 %token COND COLON
 %right COND COLON
 | Expr COND Expr COLON Expr           { Cond($1, $3, $5)    }
 
 
Testing 7.5_test1.c and 7.5_test2.c will give:

> compileToFile (fromFile "7.5_test1.c") "7.5_test1.out";;
val it: Machine.instr list =
  [LDARGS; CALL (0, "L1"); STOP; Label "L1"; CSTI 1; IFZERO "L2"; CSTI 10;
   GOTO "L3"; Label "L2"; CSTI 20; Label "L3"; RET 0; INCSP 0; RET -1]

Output:
    24 19 0 5 25 0 1 17 13 0 10 16 15 0 20 21 0 15 0 21 -1

> compileToFile (fromFile "7.5_test2.c") "7.5_test2.out";; 
val it: Machine.instr list =
  [LDARGS; CALL (0, "L1"); STOP; Label "L1"; INCSP 1; GETBP; CSTI 0; ADD;
   CSTI 0; STI; INCSP -1; GETBP; CSTI 0; ADD; CSTI 0; IFZERO "L2"; GETBP;
   CSTI 0; ADD; CSTI 5; STI; GOTO "L3"; Label "L2"; GETBP; CSTI 0; ADD; CSTI 6;
   STI; Label "L3"; STI; INCSP -1; GETBP; CSTI 0; ADD; LDI; RET 1; INCSP -1;
   RET -1]

Output:
    24 19 0 5 25 15 1 13 0 0 1 0 0 12 15 -1 13 0 0 1 0 0 17 33 13 0 0 1 0 5 12 16 40 13 0 0 1 0 6 12 12 15 -1 13 0 0 1 11 21 1 15 -1 21 -1